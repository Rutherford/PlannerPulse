"""Newsletter builder - Creates HTML, Markdown and text versions"""

import os
import logging
from datetime import datetime
from typing import Dict, Any
from jinja2 import Environment, FileSystemLoader, TemplateNotFound

logger = logging.getLogger(__name__)

def build_newsletter(newsletter_data: Dict[str, Any], config: Dict[str, Any]) -> tuple:
    """Build newsletter in HTML, Markdown and text formats.

    In addition to writing the files to the ``output`` directory this
    function now returns the generated content for each format.

    Returns a tuple ``(success, html_content, markdown_content, text_content)``.
    ``success`` will be ``True`` only if all formats were built successfully.
    """
    try:
        # Ensure output directory exists
        os.makedirs("output", exist_ok=True)

        # Build each format and capture the resulting content
        html_content = build_html_newsletter(newsletter_data, config)
        md_content = build_markdown_newsletter(newsletter_data, config)
        text_content = build_text_newsletter(newsletter_data, config)

        success = all([html_content is not None, md_content is not None, text_content is not None])

        if success:
            logger.info("Newsletter built successfully in all formats")
        else:
            logger.warning("Some newsletter formats failed to build")

        return success, html_content or "", md_content or "", text_content or ""

    except Exception as e:
        logger.error(f"Failed to build newsletter: {e}")
        return False, "", "", ""

def build_html_newsletter(newsletter_data: Dict[str, Any], config: Dict[str, Any]) -> str | None:
    """Build HTML version of newsletter.

    Returns the rendered HTML string or ``None`` on failure."""
    try:
        # Setup Jinja2 environment
        env = Environment(loader=FileSystemLoader('templates'))
        template = env.get_template("base_template.html")
        
        # Prepare template data
        template_data = {
            **newsletter_data,
            'config': config,
            'generation_date': datetime.now().strftime('%B %d, %Y'),
            'story_count': len(newsletter_data.get('stories', [])),
            'preview_text': generate_preview_text(newsletter_data.get('stories', []))
        }
        
        # Render template
        html_output = template.render(**template_data)
        
        # Write to file
        with open("output/newsletter.html", "w", encoding="utf-8") as f:
            f.write(html_output)

        logger.info("HTML newsletter created: output/newsletter.html")
        return html_output
        
    except TemplateNotFound:
        logger.error("HTML template not found: templates/base_template.html")
        return None
    except Exception as e:
        logger.error(f"Failed to build HTML newsletter: {e}")
        return None

def build_markdown_newsletter(newsletter_data: Dict[str, Any], config: Dict[str, Any]) -> str | None:
    """Build Markdown version of newsletter.

    Returns the Markdown text or ``None`` on failure."""
    try:
        md_content = []
        
        # Header
        title = newsletter_data.get('title', 'Newsletter')
        subject_line = newsletter_data.get('subject_line', '')
        
        md_content.append(f"# {title}")
        if subject_line and subject_line != title:
            md_content.append(f"*{subject_line}*")
        
        md_content.append(f"\n*Generated on {datetime.now().strftime('%B %d, %Y')}*")
        md_content.append("\n---\n")
        
        # Stories
        stories = newsletter_data.get('stories', [])
        for i, story in enumerate(stories, 1):
            md_content.append(f"## Story {i}")
            
            if isinstance(story, dict):
                if 'title' in story:
                    md_content.append(f"**{story['title']}**")
                if 'summary' in story:
                    md_content.append(story['summary'])
                if 'link' in story:
                    md_content.append(f"\n[Read More]({story['link']})")
            else:
                # Handle string summaries
                md_content.append(str(story))
            
            md_content.append("\n---\n")
        
        # Sponsor section
        sponsor = newsletter_data.get('sponsor')
        if sponsor:
            md_content.append("## Sponsor")
            md_content.append(f"**{sponsor.get('name', 'Sponsor')}**")
            md_content.append(sponsor.get('message', ''))
            if sponsor.get('link'):
                md_content.append(f"\n[Learn More]({sponsor['link']})")
            md_content.append("\n---\n")
        
        # Footer
        md_content.append(f"*This newsletter was generated by {title}*")
        
        # Write to file
        markdown_text = "\n".join(md_content)
        with open("output/newsletter.md", "w", encoding="utf-8") as f:
            f.write(markdown_text)
        
        logger.info("Markdown newsletter created: output/newsletter.md")
        return markdown_text
        
    except Exception as e:
        logger.error(f"Failed to build Markdown newsletter: {e}")
        return None

def build_text_newsletter(newsletter_data: Dict[str, Any], config: Dict[str, Any]) -> str | None:
    """Build plain text version for email compatibility.

    Returns the plain text string or ``None`` on failure."""
    try:
        text_content = []
        
        # Header
        title = newsletter_data.get('title', 'Newsletter')
        subject_line = newsletter_data.get('subject_line', '')
        
        text_content.append(title.upper())
        text_content.append("=" * len(title))
        
        if subject_line and subject_line != title:
            text_content.append(subject_line)
        
        text_content.append(f"\nGenerated on {datetime.now().strftime('%B %d, %Y')}")
        text_content.append("\n" + "-" * 50 + "\n")
        
        # Stories
        stories = newsletter_data.get('stories', [])
        for i, story in enumerate(stories, 1):
            text_content.append(f"STORY {i}")
            text_content.append("-" * 20)
            
            if isinstance(story, dict):
                if 'title' in story:
                    text_content.append(f"Title: {story['title']}")
                if 'summary' in story:
                    # Clean markdown formatting for plain text
                    clean_summary = clean_text_for_email(story['summary'])
                    text_content.append(f"Summary: {clean_summary}")
                if 'link' in story:
                    text_content.append(f"Read More: {story['link']}")
            else:
                # Handle string summaries
                clean_summary = clean_text_for_email(str(story))
                text_content.append(clean_summary)
            
            text_content.append("\n" + "-" * 50 + "\n")
        
        # Sponsor section
        sponsor = newsletter_data.get('sponsor')
        if sponsor:
            text_content.append("SPONSOR")
            text_content.append("-" * 20)
            text_content.append(f"Sponsor: {sponsor.get('name', 'Sponsor')}")
            text_content.append(sponsor.get('message', ''))
            if sponsor.get('link'):
                text_content.append(f"Learn More: {sponsor['link']}")
            text_content.append("\n" + "-" * 50 + "\n")
        
        # Footer
        text_content.append(f"This newsletter was generated by {title}")
        
        # Write to file
        plain_text = "\n".join(text_content)
        with open("output/newsletter.txt", "w", encoding="utf-8") as f:
            f.write(plain_text)
        
        logger.info("Plain text newsletter created: output/newsletter.txt")
        return plain_text
        
    except Exception as e:
        logger.error(f"Failed to build plain text newsletter: {e}")
        return None

def clean_text_for_email(text: str) -> str:
    """Remove markdown formatting for plain text email"""
    import re
    
    # Remove markdown formatting
    text = re.sub(r'\*\*(.*?)\*\*', r'\1', text)  # Bold
    text = re.sub(r'\*(.*?)\*', r'\1', text)      # Italic
    text = re.sub(r'#{1,6}\s*(.*)', r'\1', text)  # Headers
    text = re.sub(r'\[([^\]]*)\]\([^\)]*\)', r'\1', text)  # Links
    
    # Clean up extra whitespace
    text = re.sub(r'\n\s*\n', '\n\n', text)
    text = text.strip()
    
    return text

def generate_preview_text(stories) -> str:
    """Generate preview text for email clients"""
    try:
        if not stories:
            return "Your latest meeting industry updates"
        
        # Get first story summary
        first_story = stories[0]
        if isinstance(first_story, dict):
            preview = first_story.get('summary', '')
        else:
            preview = str(first_story)
        
        # Clean and truncate
        preview = clean_text_for_email(preview)
        if len(preview) > 100:
            preview = preview[:97] + "..."
        
        return preview
    except Exception:
        return "Your latest meeting industry updates"

if __name__ == "__main__":
    # Test the builder
    logging.basicConfig(level=logging.INFO)
    
    test_data = {
        'title': 'Planner Pulse',
        'subject_line': 'Major Vegas Venue Opens This Fall',
        'stories': [
            {
                'title': 'Test Article',
                'summary': '**Test Headline**\nThis is a test summary for the newsletter builder.\nðŸ”‘ **Key Takeaway:** Testing is important.',
                'link': 'https://example.com'
            }
        ],
        'sponsor': {
            'name': 'Test Sponsor',
            'message': 'This is a test sponsor message.',
            'link': 'https://sponsor.com'
        }
    }
    
    test_config = {
        'newsletter_title': 'Planner Pulse'
    }
    
    success, html_out, md_out, text_out = build_newsletter(test_data, test_config)
    print(f"Build test result: {success}")
